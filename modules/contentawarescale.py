"""
Copyright 2018 Karthik Karanth, MIT License
"""

from .base import Module, ImageUploader
import numba
from tqdm import trange
import numpy as np
from imageio import imread, imwrite
from scipy.ndimage.filters import convolve
from io import BytesIO
# TODO: This is so complicated for literally just reading an image from a URL
from skimage import io


class ContentAwareScale(Module, ImageUploader):
    def calc_energy(img):
        filter_du = np.array([
            [1.0, 2.0, 1.0],
            [0.0, 0.0, 0.0],
            [-1.0, -2.0, -1.0],
        ])
        # This converts it from a 2D filter to a 3D filter, replicating the same
        # filter for each channel: R, G, B
        filter_du = np.stack([filter_du] * 3, axis=2)

        filter_dv = np.array([
            [1.0, 0.0, -1.0],
            [2.0, 0.0, -2.0],
            [1.0, 0.0, -1.0],
        ])
        # This converts it from a 2D filter to a 3D filter, replicating the same
        # filter for each channel: R, G, B
        filter_dv = np.stack([filter_dv] * 3, axis=2)

        img = img.astype('float32')
        convolved = np.absolute(convolve(img, filter_du)) + np.absolute(convolve(img, filter_dv))

        # We sum the energies in the red, green, and blue channels
        energy_map = convolved.sum(axis=2)

        return energy_map

    def crop_c(img, scale_c):
        r, c, _ = img.shape
        new_c = int(scale_c * c)

        for i in trange(c - new_c):
            img = carve_column(img)

        return img

    def crop_r(img, scale_r):
        img = np.rot90(img, 1, (0, 1))
        img = crop_c(img, scale_r)
        img = np.rot90(img, 3, (0, 1))
        return img

    @numba.jit
    def carve_column(img):
        r, c, _ = img.shape

        M, backtrack = minimum_seam(img)
        mask = np.ones((r, c), dtype=np.bool)

        j = np.argmin(M[-1])
        for i in reversed(range(r)):
            mask[i, j] = False
            j = backtrack[i, j]

        mask = np.stack([mask] * 3, axis=2)
        img = img[mask].reshape((r, c - 1, 3))
        return img

    @numba.jit
    def minimum_seam(img):
        r, c, _ = img.shape
        energy_map = self.calc_energy(img)

        M = energy_map.copy()
        backtrack = np.zeros_like(M, dtype=np.int)

        for i in range(1, r):
            for j in range(0, c):
                # Handle the left edge of the image, to ensure we don't index a -1
                if j == 0:
                    idx = np.argmin(M[i - 1, j:j + 2])
                    backtrack[i, j] = idx + j
                    min_energy = M[i - 1, idx + j]
                else:
                    idx = np.argmin(M[i - 1, j - 1:j + 2])
                    backtrack[i, j] = idx + j - 1
                    min_energy = M[i - 1, idx + j - 1]

                M[i, j] += min_energy

        return M, backtrack


scale = 0.8
in_filename = '/Users/boesene/src/erikboesen.github.io/images/casual-small.jpg'
out_filename = '/Users/boesene/Desktop/out.jpg'

img = imread(in_filename)

out = crop_r(img, scale)
out = crop_c(out, scale)

imwrite(out_filename, out)
